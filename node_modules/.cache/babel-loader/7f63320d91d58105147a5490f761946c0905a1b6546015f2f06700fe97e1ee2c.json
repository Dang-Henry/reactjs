{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\nvar isNullOrUndefined = value => value == null;\nvar isArray = value => Array.isArray(value);\nconst isObjectType = value => typeof value === 'object';\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\nvar isHTMLElement = value => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit'\n};\nconst VALUE = 'value';\nconst UNDEFINED = 'undefined';\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst SELECT = 'select';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\nfunction attachEventListeners(_ref) {\n  let {\n    field: {\n      ref\n    },\n    handleChange,\n    isRadioOrCheckbox\n  } = _ref;\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\nvar isKey = value => !isArray(value) && (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\nvar stringToPath = string => {\n  const result = [];\n  string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\n    result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\n  });\n  return result;\n};\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\nvar transformToNestObject = data => Object.entries(data).reduce((previous, _ref2) => {\n  let [key, value] = _ref2;\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\nvar isUndefined = val => val === undefined;\nvar get = (obj, path, defaultValue) => {\n  const result = path.split(/[,[\\].]+?/).filter(Boolean).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\nvar isRadioInput = element => element.type === 'radio';\nvar isCheckBoxInput = element => element.type === 'checkbox';\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n  return isDetached(element.parentNode);\n}\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\nfunction baseGet(object, path) {\n  const updatePath = isKey(path) ? [path] : castPath(path);\n  const length = path.length;\n  let index = 0;\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n  return index == length ? object : undefined;\n}\nfunction baseSlice(array, start, end) {\n  let index = -1;\n  let length = array.length;\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start;\n  const result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\nfunction parent(object, path) {\n  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\nfunction baseUnset(object, path) {\n  const updatePath = isKey(path) ? [path] : castPath(path);\n  const childObject = parent(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  const result = !(childObject != null) || delete childObject[key];\n  let previousObjRef = undefined;\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n    if (k > 0) {\n      previousObjRef = object;\n    }\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n      if (currentPathsLength === index) {\n        if (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data)).length) {\n          previousObjRef ? delete previousObjRef[item] : delete object[item];\n        }\n      }\n      previousObjRef = objectRef;\n    }\n  }\n  return result;\n}\nfunction unset(object, paths) {\n  paths.forEach(path => {\n    baseUnset(object, path);\n  });\n  return object;\n}\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name,\n      type\n    },\n    mutationWatcher\n  } = field;\n  const fieldValue = fields[name];\n  if (!type) {\n    delete fields[name];\n    return;\n  }\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\n    const {\n      options\n    } = fieldValue;\n    if (isArray(options) && options.length) {\n      options.filter(Boolean).forEach((option, index) => {\n        const {\n          ref,\n          mutationWatcher\n        } = option;\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n          unset(options, [\"[\".concat(index, \"]\")]);\n        }\n      });\n      if (options && !options.filter(Boolean).length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldValue, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n    delete fields[name];\n  }\n}\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\nvar getMultipleSelectValue = options => [...options].filter(_ref3 => {\n  let {\n    selected\n  } = _ref3;\n  return selected;\n}).map(_ref4 => {\n  let {\n    value\n  } = _ref4;\n  return value;\n});\nvar isFileInput = element => element.type === 'file';\nvar isMultipleSelect = element => element.type === \"\".concat(SELECT, \"-multiple\");\nvar isEmptyString = value => value === '';\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(_ref5 => {\n        let {\n          ref: {\n            value\n          }\n        } = _ref5;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n  return defaultResult;\n};\nfunction getFieldValue(fields, ref) {\n  const {\n    name,\n    value\n  } = ref;\n  const field = fields[name];\n  if (isFileInput(ref)) {\n    return ref.files;\n  }\n  if (isRadioInput(ref)) {\n    return field ? getRadioValue(field.options).value : '';\n  }\n  if (isMultipleSelect(ref)) {\n    return getMultipleSelectValue(ref.options);\n  }\n  if (isCheckBoxInput(ref)) {\n    return field ? getCheckboxValue(field.options).value : false;\n  }\n  return value;\n}\nvar isString = value => typeof value === 'string';\nvar getFieldsValues = (fields, search) => {\n  const output = {};\n  for (const name in fields) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) ? search.find(data => name.startsWith(data)) : search && search.nest)) {\n      output[name] = getFieldValue(fields, fields[name].ref);\n    }\n  }\n  return output;\n};\nvar compareObject = function () {\n  let objectA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let objectB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const objectAKeys = Object.keys(objectA);\n  const objectBKeys = Object.keys(objectB);\n  return objectAKeys.length === objectBKeys.length && objectAKeys.every(key => objectB[key] && objectB[key] === objectA[key]);\n};\nvar isSameError = (error, _ref6) => {\n  let {\n    type,\n    types,\n    message\n  } = _ref6;\n  return isObject(error) && error.type === type && error.message === message && compareObject(error.types, types);\n};\nfunction shouldRenderBasedOnError(_ref7) {\n  let {\n    errors,\n    name,\n    error,\n    validFields,\n    fieldsWithValidation\n  } = _ref7;\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n  if (isFieldValid && validFields.has(name) || existFieldError && existFieldError.isManual) {\n    return false;\n  }\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\nvar isRegex = value => value instanceof RegExp;\nvar getValueAndMessage = validationData => {\n  const isValueMessage = value => isObject(value) && !isRegex(value);\n  return isValueMessage(validationData) ? validationData : {\n    value: validationData,\n    message: ''\n  };\n};\nvar isFunction = value => typeof value === 'function';\nvar isBoolean = value => typeof value === 'boolean';\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\nfunction getValidateError(result, ref) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n  return {};\n};\nvar validateField = async (fieldsRef, validateAllFieldCriteria, _ref8) => {\n  let {\n    ref,\n    ref: {\n      type,\n      value,\n      name\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  } = _ref8;\n  var _a;\n  const fields = fieldsRef.current;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = isEmptyString(value);\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {\n    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n    if (!validateAllFieldCriteria) {\n      return error;\n    }\n  };\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value: requiredValue,\n      message: requiredMessage\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n    if (requiredValue) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n  if (validate) {\n    const fieldValue = getFieldValue(fields, ref);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n  return error;\n};\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner) ? error.inner.reduce((previous, _ref9) => {\n  let {\n    path,\n    message,\n    type\n  } = _ref9;\n  return Object.assign(Object.assign({}, previous), path ? previous[path] && validateAllFieldCriteria ? {\n    [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message)\n  } : {\n    [path]: previous[path] || Object.assign({\n      message,\n      type\n    }, validateAllFieldCriteria ? {\n      types: {\n        [type]: message || true\n      }\n    } : {})\n  } : {});\n}, {}) : {\n  [error.path]: {\n    message: error.message,\n    type: error.type\n  }\n};\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\n  if (validationResolver) {\n    return validationResolver(data, context);\n  }\n  try {\n    return {\n      values: await validationSchema.validate(data, {\n        abortEarly: false,\n        context\n      }),\n      errors: {}\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria))\n    };\n  }\n}\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n  return isArray(values) ? values.map((value, key) => getInnerPath(value, key)) : Object.entries(values).map(_ref10 => {\n    let [key, value] = _ref10;\n    return getInnerPath(value, key, true);\n  });\n};\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    value = fieldValues[fieldName];\n    watchFields.add(fieldName);\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\nvar skipValidation = _ref11 => {\n  let {\n    isOnChange,\n    hasError,\n    isBlurEvent,\n    isOnSubmit,\n    isReValidateOnSubmit,\n    isOnBlur,\n    isReValidateOnBlur,\n    isSubmitted\n  } = _ref11;\n  return isOnChange && isBlurEvent || isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n};\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\nvar getFieldValueByName = (fields, name) => {\n  const results = transformToNestObject(getFieldsValues(fields));\n  return name ? get(results, name, results) : results;\n};\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  let isMatch = false;\n  if (!isArray(referenceArray) || !isArray(differenceArray) || referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n  for (let i = 0; i < referenceArray.length; i++) {\n    if (isMatch) {\n      break;\n    }\n    const dataA = referenceArray[i];\n    const dataB = differenceArray[i];\n    if (isUndefined(dataB) || Object.keys(dataA).length !== Object.keys(dataB).length) {\n      isMatch = true;\n      break;\n    }\n    for (const key in dataA) {\n      if (dataA[key] !== dataB[key]) {\n        isMatch = true;\n        break;\n      }\n    }\n  }\n  return isMatch;\n}\nconst isMatchFieldArrayName = (name, searchName) => RegExp(\"^\".concat(searchName, \"[\\\\d+]\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\nvar isSelectInput = element => element.type === \"\".concat(SELECT, \"-one\");\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange\n});\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\nfunction useForm() {\n  let {\n    mode = VALIDATION_MODE.onSubmit,\n    reValidateMode = VALIDATION_MODE.onChange,\n    validationSchema,\n    validationResolver,\n    validationContext,\n    defaultValues = {},\n    submitFocusError = true,\n    validateCriteriaMode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const fieldArrayDefaultValues = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const dirtyFieldsRef = useRef(new Set());\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const resetFieldArrayFunctionRef = useRef({});\n  const validationContextRef = useRef(validationContext);\n  const fieldArrayNamesRef = useRef(new Set());\n  const [, render] = useState();\n  const {\n    isOnBlur,\n    isOnSubmit,\n    isOnChange\n  } = useRef(modeChecker(mode)).current;\n  const validateAllFieldCriteria = validateCriteriaMode === 'all';\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\n  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n  const readFormStateRef = useRef({\n    dirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnSubmit: isReValidateOnSubmit\n  } = useRef(modeChecker(reValidateMode)).current;\n  validationContextRef.current = validationContext;\n  const reRender = useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  const shouldRenderBaseOnError = useCallback(function (name, error) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || shouldValidateSchemaOrResolver) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || get(errorsRef.current, name);\n      }\n      errorsRef.current = unset(errorsRef.current, [name]);\n    } else {\n      const previousError = get(errorsRef.current, name);\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || (previousError ? !isSameError(previousError, error[name]) : true);\n      set(errorsRef.current, name, error[name]);\n    }\n    if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n      reRender();\n      return true;\n    }\n  }, [reRender, shouldValidateSchemaOrResolver]);\n  const setFieldValue = useCallback((field, rawValue) => {\n    const {\n      ref,\n      options\n    } = field;\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n    if (isRadioInput(ref) && options) {\n      options.forEach(_ref12 => {\n        let {\n          ref: radioRef\n        } = _ref12;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref)) {\n      if (isString(value)) {\n        ref.value = value;\n      } else {\n        ref.files = value;\n      }\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(_ref13 => {\n        let {\n          ref: checkboxRef\n        } = _ref13;\n        return checkboxRef.checked = value.includes(checkboxRef.value);\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, [isWeb]);\n  const setDirty = useCallback(name => {\n    if (!fieldsRef.current[name] || !readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields) {\n      return false;\n    }\n    let isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\n    if (isFieldArray) {\n      const fieldArrayName = getFieldArrayParentName(name);\n      isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\n    }\n    const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !== isFieldDirty;\n    if (isFieldDirty) {\n      dirtyFieldsRef.current.add(name);\n    } else {\n      dirtyFieldsRef.current.delete(name);\n    }\n    isDirtyRef.current = isFieldArray ? isFieldDirty : !!dirtyFieldsRef.current.size;\n    return readFormStateRef.current.dirty ? isDirtyChanged : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\n  }, []);\n  const setInternalValues = useCallback((name, value, parentFieldName) => {\n    const isValueArray = isArray(value);\n    for (const key in value) {\n      const fieldName = \"\".concat(parentFieldName || name).concat(isValueArray ? \"[\".concat(key, \"]\") : \".\".concat(key));\n      const field = fieldsRef.current[fieldName];\n      if (isObject(value[key])) {\n        setInternalValues(name, value[key], fieldName);\n      }\n      if (field) {\n        setFieldValue(field, value[key]);\n        setDirty(fieldName);\n      }\n    }\n  }, [setFieldValue, setDirty]);\n  const setInternalValue = useCallback((name, value) => {\n    const field = fieldsRef.current[name];\n    if (field) {\n      setFieldValue(field, value);\n      const output = setDirty(name);\n      if (isBoolean(output)) {\n        return output;\n      }\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value);\n    }\n  }, [setDirty, setFieldValue, setInternalValues]);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    const field = fieldsRef.current[name];\n    if (field) {\n      const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n      shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n      return isEmptyObject(error);\n    }\n    return false;\n  }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async payload => {\n    const {\n      errors\n    } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\n    const previousFormIsValid = isValidRef.current;\n    isValidRef.current = isEmptyObject(errors);\n    if (isArray(payload)) {\n      payload.forEach(name => {\n        const error = get(errors, name);\n        if (error) {\n          set(errorsRef.current, name, error);\n        } else {\n          unset(errorsRef.current, [name]);\n        }\n      });\n      reRender();\n    } else {\n      const error = get(errors, payload);\n      shouldRenderBaseOnError(payload, error ? {\n        [payload]: error\n      } : {}, previousFormIsValid !== isValidRef.current);\n    }\n    return isEmptyObject(errorsRef.current);\n  }, [reRender, shouldRenderBaseOnError, validateAllFieldCriteria, validationResolver, validationSchema]);\n  const triggerValidation = useCallback(async payload => {\n    const fields = payload || Object.keys(fieldsRef.current);\n    if (shouldValidateSchemaOrResolver) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, true)));\n      reRender();\n      return result.every(Boolean);\n    }\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation, reRender, shouldValidateSchemaOrResolver]);\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n  function setValue(names, valueOrShouldValidate, shouldValidate) {\n    let shouldRender = false;\n    const isArrayValue = isArray(names);\n    (isArrayValue ? names : [names]).forEach(name => {\n      const isStringFieldName = isString(name);\n      shouldRender = setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName ? valueOrShouldValidate : Object.values(name)[0]) || isArrayValue ? true : isFieldWatched(name);\n    });\n    if (shouldRender || isArrayValue) {\n      reRender();\n    }\n    if (shouldValidate || isArrayValue && valueOrShouldValidate) {\n      triggerValidation(isArrayValue ? undefined : names);\n    }\n  }\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async _ref14 => {\n    let {\n      type,\n      target\n    } = _ref14;\n    const name = target ? target.name : '';\n    const fields = fieldsRef.current;\n    const errors = errorsRef.current;\n    const field = fields[name];\n    const currentError = get(errors, name);\n    let error;\n    if (!field) {\n      return;\n    }\n    const isBlurEvent = type === EVENTS.BLUR;\n    const shouldSkipValidation = skipValidation({\n      hasError: !!currentError,\n      isOnChange,\n      isBlurEvent,\n      isOnSubmit,\n      isReValidateOnSubmit,\n      isOnBlur,\n      isReValidateOnBlur,\n      isSubmitted: isSubmittedRef.current\n    });\n    const shouldUpdateDirty = setDirty(name);\n    let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\n    if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {\n      set(touchedFieldsRef.current, name, true);\n      shouldRender = true;\n    }\n    if (shouldSkipValidation) {\n      return shouldRender && reRender();\n    }\n    if (shouldValidateSchemaOrResolver) {\n      const {\n        errors\n      } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n      error = get(errors, name) ? {\n        [name]: get(errors, name)\n      } : {};\n      if (previousFormIsValid !== isValidRef.current) {\n        shouldRender = true;\n      }\n    } else {\n      error = await validateField(fieldsRef, validateAllFieldCriteria, field);\n    }\n    if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n      reRender();\n    }\n  };\n  const validateSchemaOrResolver = useCallback(function () {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(_ref15 => {\n      let {\n        errors\n      } = _ref15;\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n      if (previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [reRender, validateAllFieldCriteria, validationResolver]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    if (handleChangeRef.current && field) {\n      findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\n    }\n  }, []);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (!field || field && isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) && !forceDelete) {\n      return;\n    }\n    removeFieldEventListener(field, forceDelete);\n    const {\n      name\n    } = field.ref;\n    errorsRef.current = unset(errorsRef.current, [name]);\n    touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\n    defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\n    [dirtyFieldsRef, fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(data => data.current.delete(name));\n    if (readFormStateRef.current.isValid || readFormStateRef.current.touched) {\n      reRender();\n      if (shouldValidateSchemaOrResolver) {\n        validateSchemaOrResolver();\n      }\n    }\n  }, [reRender, shouldValidateSchemaOrResolver, validateSchemaOrResolver, removeFieldEventListener]);\n  function clearError(name) {\n    if (name) {\n      unset(errorsRef.current, isArray(name) ? name : [name]);\n    } else {\n      errorsRef.current = {};\n    }\n    reRender();\n  }\n  const setInternalError = _ref16 => {\n    let {\n      name,\n      type,\n      types,\n      message,\n      shouldRender\n    } = _ref16;\n    const field = fieldsRef.current[name];\n    if (!isSameError(get(errorsRef.current, name), {\n      type,\n      message,\n      types\n    })) {\n      set(errorsRef.current, name, {\n        type,\n        types,\n        message,\n        ref: field ? field.ref : {},\n        isManual: true\n      });\n      if (shouldRender) {\n        reRender();\n      }\n    }\n  };\n  function setError(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let message = arguments.length > 2 ? arguments[2] : undefined;\n    if (isString(name)) {\n      setInternalError(Object.assign(Object.assign({\n        name\n      }, isObject(type) ? {\n        types: type,\n        type: ''\n      } : {\n        type,\n        message\n      }), {\n        shouldRender: true\n      }));\n    } else if (isArray(name)) {\n      name.forEach(error => setInternalError(Object.assign({}, error)));\n      reRender();\n    }\n  }\n  function watch(fieldNames, defaultValue) {\n    const watchFields = watchFieldsRef.current;\n    const isDefaultValueUndefined = isUndefined(defaultValue);\n    const combinedDefaultValues = isDefaultValueUndefined ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n    isWatchAllRef.current = true;\n    const result = !isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues;\n    return fieldNames && fieldNames.nest ? transformToNestObject(result) : result;\n  }\n  function unregister(name) {\n    if (fieldsRef.current) {\n      (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n    }\n  }\n  function registerFieldsRef(ref) {\n    let validateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ref.name) {\n      // eslint-disable-next-line no-console\n      return console.warn('Missing name @', ref);\n    }\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n    if (isRadioOrCheckbox ? field && isArray(field.options) && field.options.filter(Boolean).find(option => {\n      return value === option.ref.value && option.ref === ref;\n    }) : field && ref === field.ref) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...(field && field.options || []), {\n          ref,\n          mutationWatcher\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), {\n        mutationWatcher\n      });\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n    fields[name] = field;\n    if (!isEmptyObject(defaultValuesRef.current)) {\n      defaultValue = get(defaultValuesRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n    if (shouldValidateSchemaOrResolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateSchemaOrResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, validateAllFieldCriteria, field).then(error => {\n          const previousFormIsValid = isValidRef.current;\n          isEmptyObject(error) ? validFieldsRef.current.add(name) : isValidRef.current = false;\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\n    }\n    if (type) {\n      attachEventListeners({\n        field: isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field,\n        isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\n        handleChange: handleChangeRef.current\n      });\n    }\n  }\n  function register(refOrValidationOptions, validationOptions) {\n    if (isWindowUndefined) {\n      return;\n    }\n    if (isString(refOrValidationOptions)) {\n      registerFieldsRef({\n        name: refOrValidationOptions\n      }, validationOptions);\n      return;\n    }\n    if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n      registerFieldsRef(refOrValidationOptions, validationOptions);\n      return;\n    }\n    return ref => ref && registerFieldsRef(ref, refOrValidationOptions);\n  }\n  const handleSubmit = useCallback(callback => async e => {\n    if (e) {\n      e.preventDefault();\n      e.persist();\n    }\n    let fieldErrors = {};\n    const fields = fieldsRef.current;\n    let fieldValues = getFieldsValues(fields);\n    if (readFormStateRef.current.isSubmitting) {\n      isSubmittingRef.current = true;\n      reRender();\n    }\n    try {\n      if (shouldValidateSchemaOrResolver) {\n        const {\n          errors,\n          values\n        } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\n        errorsRef.current = errors;\n        fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fields)) {\n          if (field) {\n            const {\n              ref: {\n                name\n              }\n            } = field;\n            const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              validFieldsRef.current.delete(name);\n            } else {\n              if (fieldsWithValidationRef.current.has(name)) {\n                validFieldsRef.current.add(name);\n              }\n            }\n          }\n        }\n      }\n      if (isEmptyObject(fieldErrors)) {\n        errorsRef.current = {};\n        reRender();\n        await callback(transformToNestObject(fieldValues), e);\n      } else {\n        errorsRef.current = fieldErrors;\n        if (submitFocusError && isWeb) {\n          focusOnErrorField(fields, fieldErrors);\n        }\n      }\n    } finally {\n      isSubmittedRef.current = true;\n      isSubmittingRef.current = false;\n      submitCountRef.current = submitCountRef.current + 1;\n      reRender();\n    }\n  }, [isWeb, reRender, shouldValidateSchemaOrResolver, submitFocusError, validateAllFieldCriteria, validationResolver, validationSchema]);\n  const resetRefs = _ref17 => {\n    let {\n      errors,\n      dirty,\n      isSubmitted,\n      touched,\n      isValid,\n      submitCount,\n      dirtyFields\n    } = _ref17;\n    fieldsRef.current = {};\n    if (!errors) {\n      errorsRef.current = {};\n    }\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n    if (!dirty) {\n      isDirtyRef.current = false;\n    }\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = new Set();\n    }\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValues.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n  const reset = function (values) {\n    let omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n    reRender();\n  };\n  function getValues(payload) {\n    if (isString(payload)) {\n      return fieldsRef.current[payload] ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref) : get(defaultValuesRef.current, payload);\n    }\n    const fieldValues = getFieldsValues(fieldsRef.current);\n    const outputValues = isEmptyObject(fieldValues) ? defaultValuesRef.current : fieldValues;\n    return payload && payload.nest ? transformToNestObject(outputValues) : outputValues;\n  }\n  useEffect(() => () => {\n    isUnMount.current = true;\n    fieldsRef.current && process.env.NODE_ENV === 'production' && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n  }, [removeFieldEventListenerAndRef]);\n  if (!shouldValidateSchemaOrResolver) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n  const formState = {\n    dirty: isDirtyRef.current,\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current\n  };\n  const commonProps = {\n    triggerValidation,\n    setValue: useCallback(setValue, [reRender, setInternalValue, triggerValidation]),\n    register: useCallback(register, [defaultValuesRef.current, defaultValuesAtRenderRef.current]),\n    unregister: useCallback(unregister, []),\n    getValues: useCallback(getValues, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = Object.assign(Object.assign(Object.assign({\n    removeFieldEventListener,\n    reRender\n  }, shouldValidateSchemaOrResolver ? {\n    validateSchemaIsValid: validateSchemaOrResolver\n  } : {}), {\n    mode: {\n      isOnBlur,\n      isOnSubmit,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    readFormStateRef,\n    defaultValuesRef\n  }), commonProps);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearError: useCallback(clearError, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current\n  }, commonProps);\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nconst FormGlobalContext = createContext(null);\nfunction useFormContext() {\n  return useContext(FormGlobalContext);\n}\nfunction FormContext(_a) {\n  var {\n      children,\n      formState,\n      errors\n    } = _a,\n    restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\n  return createElement(FormGlobalContext.Provider, {\n    value: Object.assign(Object.assign({}, restMethods), {\n      formState,\n      errors\n    })\n  }, children);\n}\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, isObject(value) ? value : {\n  value\n});\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\nvar getSortRemovedItems = function (indexes, removeIndexes) {\n  let updatedIndexes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let notFoundIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  for (const removeIndex of removeIndexes) {\n    if (indexes.indexOf(removeIndex) < 0) {\n      notFoundIndexes.push(removeIndex);\n    }\n  }\n  for (const index of indexes.sort()) {\n    if (removeIndexes.indexOf(index) > -1) {\n      updatedIndexes.push(-1);\n      count++;\n    } else {\n      updatedIndexes.push(index - count - (notFoundIndexes.length ? notFoundIndexes.map(notFoundIndex => notFoundIndex < index).filter(Boolean).length : 0));\n    }\n  }\n  return updatedIndexes;\n};\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n  return data.filter(Boolean);\n}\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || null]), ...data];\n}\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || null]), ...data.slice(index)];\n}\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(null) : null;\nconst useFieldArray = _ref18 => {\n  let {\n    control,\n    name,\n    keyName = 'id'\n  } = _ref18;\n  const methods = useFormContext();\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    reRender,\n    fieldsRef,\n    getValues,\n    defaultValuesRef,\n    removeFieldEventListener,\n    errorsRef,\n    dirtyFieldsRef,\n    isDirtyRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValues,\n    validateSchemaIsValid\n  } = control || methods.control;\n  const getDefaultValues = () => [...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)] ? fieldArrayDefaultValues.current : defaultValuesRef.current, name, [])];\n  const memoizedDefaultValues = useRef(getDefaultValues());\n  const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  const [isDeleted, setIsDeleted] = useState(false);\n  const allFields = useRef(fields);\n  const isNameKey = isKey(name);\n  allFields.current = fields;\n  if (isNameKey) {\n    fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\n  }\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n  const setFieldAndValidState = fieldsValues => {\n    setField(fieldsValues);\n    if (readFormStateRef.current.isValid && validateSchemaIsValid) {\n      validateSchemaIsValid({\n        [name]: fieldsValues\n      });\n    }\n  };\n  const modifyDirtyFields = function () {\n    let {\n      shouldRender,\n      isRemove,\n      isPrePend,\n      index,\n      value = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let render = shouldRender;\n    const values = isArray(value) ? value : [value];\n    if (readFormStateRef.current.dirty) {\n      const dirtyFieldIndexesAndValues = {};\n      if (isPrePend || isRemove) {\n        for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\n          if (isMatchFieldArrayName(dirtyField, name)) {\n            const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\n            if (matchedIndexes) {\n              const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\n              if (dirtyFieldIndexesAndValues[matchIndex]) {\n                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\n              } else {\n                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\n              }\n            }\n            dirtyFieldsRef.current.delete(dirtyField);\n          }\n        }\n      }\n      if (!isUndefined(index) || isPrePend) {\n        const updatedDirtyFieldIndexes = isUndefined(index) ? [] : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map(i => +i), isArray(index) ? index : [index]);\n        Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\n          const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\n          if (updateIndex > -1) {\n            for (const value of values) {\n              const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\n              if (matchedIndexes) {\n                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, \"\".concat(isPrePend ? +matchedIndexes[matchedIndexes.length - 1] + values.length : updateIndex, \"$1\")));\n              }\n            }\n          }\n        });\n      }\n      if (!isRemove) {\n        values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach(key => dirtyFieldsRef.current.add(\"\".concat(name, \"[\").concat(isPrePend ? index : allFields.current.length + index, \"].\").concat(key))));\n        isDirtyRef.current = true;\n      }\n      render = true;\n    }\n    if (render && !isWatchAllRef.current) {\n      reRender();\n    }\n  };\n  const resetFields = flagOrFields => {\n    if (readFormStateRef.current.dirty) {\n      isDirtyRef.current = isUndefined(flagOrFields) ? true : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\n    }\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n  const mapCurrentFieldsValueWithState = () => {\n    const currentFieldsValue = get(getValues({\n      nest: true\n    }), name);\n    if (isArray(currentFieldsValue)) {\n      for (let i = 0; i < currentFieldsValue.length; i++) {\n        allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\n      }\n    }\n  };\n  const append = value => {\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n    modifyDirtyFields({\n      value\n    });\n  };\n  const prepend$1 = value => {\n    let shouldRender = false;\n    resetFields();\n    setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\n      shouldRender = true;\n    }\n    modifyDirtyFields({\n      shouldRender,\n      isPrePend: true,\n      value\n    });\n  };\n  const remove = index => {\n    let shouldRender = false;\n    const isIndexUndefined = isUndefined(index);\n    if (!isIndexUndefined) {\n      mapCurrentFieldsValueWithState();\n    }\n    resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(removeArrayAt(allFields.current, index));\n    setIsDeleted(true);\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\n      if (!errorsRef.current[name].filter(Boolean).length) {\n        delete errorsRef.current[name];\n      }\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\n      shouldRender = true;\n    }\n    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n        if (!isFound) {\n          continue;\n        }\n        for (const key in fields[fieldIndex]) {\n          const currentFieldName = \"\".concat(name, \"[\").concat(fieldIndex, \"].\").concat(key);\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(currentFieldName);\n            fieldsWithValidationRef.current.delete(currentFieldName);\n          } else {\n            const previousFieldName = \"\".concat(name, \"[\").concat(fieldIndex - 1, \"].\").concat(key);\n            if (validFieldsRef.current.has(currentFieldName)) {\n              validFieldsRef.current.add(previousFieldName);\n            }\n            if (fieldsWithValidationRef.current.has(currentFieldName)) {\n              fieldsWithValidationRef.current.add(previousFieldName);\n            }\n          }\n        }\n      }\n    }\n    modifyDirtyFields({\n      shouldRender,\n      isRemove: true,\n      index\n    });\n  };\n  const insert$1 = (index, value) => {\n    mapCurrentFieldsValueWithState();\n    resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    if (errorsRef.current[name]) {\n      errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\n      reRender();\n    }\n  };\n  const swap = (indexA, indexB) => {\n    mapCurrentFieldsValueWithState();\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    swapArrayAt(allFields.current, indexA, indexB);\n    setFieldAndValidState([...allFields.current]);\n    if (errorsRef.current[name]) {\n      swapArrayAt(errorsRef.current[name], indexA, indexB);\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\n      reRender();\n    }\n  };\n  const move = (from, to) => {\n    mapCurrentFieldsValueWithState();\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    moveArrayAt(allFields.current, from, to);\n    setFieldAndValidState([...allFields.current]);\n    if (errorsRef.current[name]) {\n      moveArrayAt(errorsRef.current[name], from, to);\n    }\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      moveArrayAt(touchedFieldsRef.current[name], from, to);\n      reRender();\n    }\n  };\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setField(mapIds(memoizedDefaultValues.current, keyName));\n  };\n  useEffect(() => {\n    if (isNameKey && isDeleted && fieldArrayDefaultValues.current[name] && fields.length < fieldArrayDefaultValues.current[name].length) {\n      fieldArrayDefaultValues.current[name].pop();\n    }\n  }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\n  useEffect(() => {\n    if (isWatchAllRef && isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          reRender();\n          break;\n        }\n      }\n    }\n  }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [fields, name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isCheckboxInput || isUndefined(event.target.value) ? event.target.checked : event.target.value;\nconst Controller = _a => {\n  var {\n      name,\n      rules,\n      as: InnerComponent,\n      onBlur,\n      onChange,\n      onChangeName = VALIDATION_MODE.onChange,\n      onBlurName = VALIDATION_MODE.onBlur,\n      valueName,\n      defaultValue,\n      control,\n      onFocus\n    } = _a,\n    rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\n  const methods = useFormContext();\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    errorsRef,\n    removeFieldEventListener,\n    triggerValidation,\n    mode: {\n      isOnSubmit,\n      isOnBlur,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    formState: {\n      isSubmitted\n    },\n    touchedFieldsRef,\n    readFormStateRef,\n    reRender,\n    fieldsRef,\n    fieldArrayNamesRef\n  } = control || methods.control;\n  const [value, setInputStateValue] = useState(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);\n  const valueRef = useRef(value);\n  const isCheckboxInput = isBoolean(value);\n  const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\n  const rulesRef = useRef(rules);\n  const onFocusRef = useRef(onFocus);\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  rulesRef.current = rules;\n  const shouldValidate = () => !skipValidation({\n    hasError: !!get(errorsRef.current, name),\n    isOnBlur,\n    isOnSubmit,\n    isOnChange,\n    isReValidateOnBlur,\n    isReValidateOnSubmit,\n    isSubmitted\n  });\n  const commonTask = event => {\n    const data = getInputValue(event, isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n  const eventWrapper = event => function () {\n    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n      arg[_key] = arguments[_key];\n    }\n    return setValue(name, commonTask(event(arg)), shouldValidate());\n  };\n  const handleChange = event => {\n    const data = commonTask(event);\n    setValue(name, data, shouldValidate());\n  };\n  const registerField = useCallback(() => {\n    if (!isNotFieldArray) {\n      removeFieldEventListener(fieldsRef.current[name], true);\n    }\n    register(Object.defineProperty({\n      name,\n      focus: onFocusRef.current\n    }, VALUE, {\n      set(data) {\n        setInputStateValue(data);\n        valueRef.current = data;\n      },\n      get() {\n        return valueRef.current;\n      }\n    }), rulesRef.current);\n  }, [isNotFieldArray, fieldsRef, rulesRef, name, onFocusRef, register, removeFieldEventListener]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue);\n      }\n    }\n  });\n  const props = Object.assign(Object.assign(Object.assign(Object.assign({\n    name\n  }, rest), onChange ? {\n    [onChangeName]: eventWrapper(onChange)\n  } : {\n    [onChangeName]: handleChange\n  }), {\n    [onBlurName]: function () {\n      if (onBlur) {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        onBlur(args);\n      }\n      if (readFormStateRef.current.touched && !get(touchedFieldsRef.current, name)) {\n        set(touchedFieldsRef.current, name, true);\n        reRender();\n      }\n      if (shouldReValidateOnBlur) {\n        triggerValidation(name);\n      }\n    }\n  }), {\n    [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value\n  });\n  return isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, props);\n};\nconst ErrorMessage = _a => {\n  var {\n      as: InnerComponent,\n      errors,\n      name,\n      message,\n      children\n    } = _a,\n    rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\n  const methods = useFormContext();\n  const error = get(errors || methods.errors, name);\n  if (!error) {\n    return null;\n  }\n  const {\n    message: messageFromRegister,\n    types\n  } = error;\n  const props = Object.assign(Object.assign({}, InnerComponent ? rest : {}), {\n    children: children ? children({\n      message: messageFromRegister || message,\n      messages: types\n    }) : messageFromRegister || message\n  });\n  return InnerComponent ? isValidElement(InnerComponent) ? cloneElement(InnerComponent, props) : createElement(InnerComponent, props) : createElement(Fragment, Object.assign({}, props));\n};\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };","map":{"version":3,"names":["isValidElement","useRef","useState","useCallback","useEffect","createContext","useContext","createElement","cloneElement","Fragment","isNullOrUndefined","value","isArray","Array","isObjectType","isObject","isHTMLElement","nodeType","Node","ELEMENT_NODE","VALIDATION_MODE","onBlur","onChange","onSubmit","VALUE","UNDEFINED","EVENTS","BLUR","CHANGE","INPUT","SELECT","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","REGEX_IS_DEEP_PROP","REGEX_IS_PLAIN_PROP","REGEX_PROP_NAME","REGEX_ESCAPE_CHAR","REGEX_ARRAY_FIELD_INDEX","attachEventListeners","_ref","field","ref","handleChange","isRadioOrCheckbox","addEventListener","isKey","test","stringToPath","string","result","replace","match","number","quote","push","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","Object","entries","reduce","previous","_ref2","assign","isUndefined","val","undefined","get","obj","defaultValue","split","filter","Boolean","focusOnErrorField","fields","fieldErrors","focus","options","removeAllEventListeners","validateWithStateUpdate","removeEventListener","isRadioInput","element","type","isCheckBoxInput","isDetached","HTMLElement","DOCUMENT_NODE","parentNode","isEmptyObject","keys","castPath","baseGet","updatePath","baseSlice","array","start","end","parent","baseUnset","childObject","previousObjRef","k","slice","objectRef","currentPaths","currentPathsLength","item","unset","paths","forEach","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","forceDelete","name","mutationWatcher","option","disconnect","concat","defaultReturn","isValid","getRadioValue","checked","getMultipleSelectValue","_ref3","selected","map","_ref4","isFileInput","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","values","_ref5","attributes","getFieldValue","files","isString","getFieldsValues","search","output","startsWith","find","nest","compareObject","objectA","arguments","objectB","objectAKeys","objectBKeys","every","isSameError","error","_ref6","types","message","shouldRenderBasedOnError","_ref7","errors","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","isRegex","RegExp","getValueAndMessage","validationData","isValueMessage","isFunction","isBoolean","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","validateField","fieldsRef","_ref8","_a","current","isRadio","isCheckBox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","requiredValue","requiredMessage","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","valueAsNumber","parseFloat","valueDate","valueAsDate","Date","maxLengthValue","minLengthValue","inputLength","toString","patternValue","patternMessage","validateRef","validateError","validationResult","validateFunction","validateResult","parseErrorSchema","inner","_ref9","validateWithSchema","validationSchema","validationResolver","context","abortEarly","e","isPrimitive","getPath","getInnerPath","pathWithIndex","_ref10","getPath$1","parentPath","flat","Infinity","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","skipValidation","_ref11","isOnChange","hasError","isBlurEvent","isOnSubmit","isReValidateOnSubmit","isOnBlur","isReValidateOnBlur","isSubmitted","getFieldArrayParentName","substring","indexOf","getFieldValueByName","results","getIsFieldsDifferent","referenceArray","differenceArray","isMatch","i","dataA","dataB","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isSelectInput","onDomRemove","onDetachCallback","observer","MutationObserver","observe","window","document","childList","subtree","modeChecker","mode","isRadioOrCheckboxFunction","useForm","reValidateMode","validationContext","defaultValues","submitFocusError","validateCriteriaMode","errorsRef","touchedFieldsRef","fieldArrayDefaultValues","watchFieldsRef","Set","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","handleChangeRef","resetFieldArrayFunctionRef","validationContextRef","fieldArrayNamesRef","render","isWindowUndefined","shouldValidateSchemaOrResolver","isWeb","isProxyEnabled","Proxy","readFormStateRef","dirty","dirtyFields","submitCount","touched","isSubmitting","reRender","shouldRenderBaseOnError","shouldRender","shouldReRender","previousError","delete","setFieldValue","rawValue","_ref12","radioRef","selectRef","includes","_ref13","checkboxRef","setDirty","isFieldDirty","isFieldArray","previousDirtyFieldsLength","size","fieldArrayName","isDirtyChanged","setInternalValues","parentFieldName","isValueArray","setInternalValue","executeValidation","skipReRender","executeSchemaOrResolverValidation","payload","previousFormIsValid","triggerValidation","Promise","all","isFieldWatched","setValue","valueOrShouldValidate","shouldValidate","isArrayValue","isStringFieldName","_ref14","target","currentError","shouldSkipValidation","shouldUpdateDirty","validateSchemaOrResolver","then","_ref15","removeFieldEventListener","removeFieldEventListenerAndRef","clearError","setInternalError","_ref16","setError","watch","fieldNames","isDefaultValueUndefined","combinedDefaultValues","unregister","registerFieldsRef","validateOptions","console","warn","fieldRefAndValidationOptions","isEmptyDefaultValue","register","refOrValidationOptions","validationOptions","handleSubmit","callback","preventDefault","persist","fieldError","resetRefs","_ref17","reset","omitResetState","inputRef","closest","resetFieldArray","getValues","outputValues","process","env","NODE_ENV","formState","commonProps","prop","control","validateSchemaIsValid","__rest","s","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","propertyIsEnumerable","FormGlobalContext","useFormContext","FormContext","children","restMethods","Provider","generateId","d","performance","now","c","r","Math","random","appendId","keyName","mapIds","getSortRemovedItems","indexes","removeIndexes","updatedIndexes","count","notFoundIndexes","removeIndex","sort","notFoundIndex","removeAt","removeAtIndexes","removeArrayAt","moveArrayAt","from","to","splice","swapArrayAt","indexA","indexB","temp","prepend","insert","fillEmptyArray","fill","useFieldArray","_ref18","methods","getDefaultValues","memoizedDefaultValues","setField","isDeleted","setIsDeleted","allFields","isNameKey","appendValueWithKey","setFieldAndValidState","fieldsValues","modifyDirtyFields","isRemove","isPrePend","dirtyFieldIndexesAndValues","dirtyField","matchedIndexes","matchIndex","updatedDirtyFieldIndexes","updateIndex","resetFields","flagOrFields","mapCurrentFieldsValueWithState","currentFieldsValue","append","prepend$1","remove","isIndexUndefined","fieldIndex","isFound","isLast","isCurrentIndex","currentFieldName","previousFieldName","insert$1","swap","move","pop","watchField","resetFunctions","fieldArrayNames","getInputValue","event","isCheckboxInput","Controller","rules","as","InnerComponent","onChangeName","onBlurName","valueName","onFocus","rest","setInputStateValue","valueRef","shouldReValidateOnBlur","rulesRef","onFocusRef","isNotFieldArray","commonTask","eventWrapper","_len","arg","_key","registerField","defineProperty","props","_len2","args","_key2","ErrorMessage","messageFromRegister","messages"],"sources":["/Users/huandang/Documents/1.Develop/1.1.ProjectGithub/reactjs/node_modules/react-hook-form/dist/react-hook-form.es.js"],"sourcesContent":["import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement, Fragment } from 'react';\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isHTMLElement = (value) => isObject(value) && value.nodeType === Node.ELEMENT_NODE;\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst VALUE = 'value';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst SELECT = 'select';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\r\nconst REGEX_IS_DEEP_PROP = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst REGEX_IS_PLAIN_PROP = /^\\w*$/;\r\nconst REGEX_PROP_NAME = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst REGEX_ESCAPE_CHAR = /\\\\(\\\\)?/g;\r\nconst REGEX_ARRAY_FIELD_INDEX = /[\\d+]/g;\n\nfunction attachEventListeners({ field: { ref }, handleChange, isRadioOrCheckbox, }) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isKey = (value) => !isArray(value) &&\r\n    (REGEX_IS_PLAIN_PROP.test(value) || !REGEX_IS_DEEP_PROP.test(value));\n\nvar stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(REGEX_PROP_NAME, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(REGEX_ESCAPE_CHAR, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction castPath(value) {\r\n    return isArray(value) ? value : stringToPath(value);\r\n}\r\nfunction baseGet(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return index == length ? object : undefined;\r\n}\r\nfunction baseSlice(array, start, end) {\r\n    let index = -1;\r\n    let length = array.length;\r\n    if (start < 0) {\r\n        start = -start > length ? 0 : length + start;\r\n    }\r\n    end = end > length ? length : end;\r\n    if (end < 0) {\r\n        end += length;\r\n    }\r\n    length = start > end ? 0 : end - start;\r\n    const result = Array(length);\r\n    while (++index < length) {\r\n        result[index] = array[index + start];\r\n    }\r\n    return result;\r\n}\r\nfunction parent(object, path) {\r\n    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\r\n}\r\nfunction baseUnset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : castPath(path);\r\n    const childObject = parent(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    const result = !(childObject != null) || delete childObject[key];\r\n    let previousObjRef = undefined;\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index) {\r\n                if ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length)) {\r\n                    previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n                }\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction unset(object, paths) {\r\n    paths.forEach((path) => {\r\n        baseUnset(object, path);\r\n    });\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldValue = fields[name];\r\n    if (!type) {\r\n        delete fields[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.filter(Boolean).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, [`[${index}]`]);\r\n                }\r\n            });\r\n            if (options && !options.filter(Boolean).length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldValue, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { name, value } = ref;\r\n    const field = fields[name];\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return getMultipleSelectValue(ref.options);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\r\n    const output = {};\r\n    for (const name in fields) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search)\r\n                    ? search.find((data) => name.startsWith(data))\r\n                    : search && search.nest)) {\r\n            output[name] = getFieldValue(fields, fields[name].ref);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\r\n    const objectAKeys = Object.keys(objectA);\r\n    const objectBKeys = Object.keys(objectB);\r\n    return (objectAKeys.length === objectBKeys.length &&\r\n        objectAKeys.every((key) => objectB[key] && objectB[key] === objectA[key]));\r\n};\n\nvar isSameError = (error, { type, types, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isValueMessage = (value) => isObject(value) && !isRegex(value);\r\n    return isValueMessage(validationData)\r\n        ? validationData\r\n        : {\r\n            value: validationData,\r\n            message: '',\r\n        };\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value, name }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    var _a;\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path\r\n        ? previous[path] && validateAllFieldCriteria\r\n            ? {\r\n                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n            }\r\n            : {\r\n                [path]: previous[path] || Object.assign({ message,\r\n                    type }, (validateAllFieldCriteria\r\n                    ? {\r\n                        types: { [type]: message || true },\r\n                    }\r\n                    : {})),\r\n            }\r\n        : {}))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validateAllFieldCriteria, data, validationResolver, context) {\r\n    if (validationResolver) {\r\n        return validationResolver(data, context);\r\n    }\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, {\r\n                abortEarly: false,\r\n                context,\r\n            }),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),\r\n        };\r\n    }\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return isArray(values)\r\n        ? values.map((value, key) => getInnerPath(value, key))\r\n        : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\r\n};\r\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        value = fieldValues[fieldName];\r\n        watchFields.add(fieldName);\r\n    }\r\n    else {\r\n        value = get(transformToNestObject(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnChange, hasError, isBlurEvent, isOnSubmit, isReValidateOnSubmit, isOnBlur, isReValidateOnBlur, isSubmitted, }) => (isOnChange && isBlurEvent) ||\r\n    (isOnSubmit && isReValidateOnSubmit) ||\r\n    (isOnSubmit && !isSubmitted) ||\r\n    (isOnBlur && !isBlurEvent && !hasError) ||\r\n    (isReValidateOnBlur && !isBlurEvent && hasError) ||\r\n    (isReValidateOnSubmit && isSubmitted);\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\r\n    const results = transformToNestObject(getFieldsValues(fields));\r\n    return name ? get(results, name, results) : results;\r\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\r\n    let isMatch = false;\r\n    if (!isArray(referenceArray) ||\r\n        !isArray(differenceArray) ||\r\n        referenceArray.length !== differenceArray.length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < referenceArray.length; i++) {\r\n        if (isMatch) {\r\n            break;\r\n        }\r\n        const dataA = referenceArray[i];\r\n        const dataB = differenceArray[i];\r\n        if (isUndefined(dataB) ||\r\n            Object.keys(dataA).length !== Object.keys(dataB).length) {\r\n            isMatch = true;\r\n            break;\r\n        }\r\n        for (const key in dataA) {\r\n            if (dataA[key] !== dataB[key]) {\r\n                isMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return isMatch;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, validationResolver, validationContext, defaultValues = {}, submitFocusError = true, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef({});\r\n    const fieldArrayDefaultValues = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidRef = useRef(true);\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const validationContextRef = useRef(validationContext);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit, isOnChange } = useRef(modeChecker(mode)).current;\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const shouldValidateSchemaOrResolver = !!(validationSchema || validationResolver);\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\n    const readFormStateRef = useRef({\r\n        dirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    validationContextRef.current = validationContext;\r\n    const reRender = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) ||\r\n                shouldValidateSchemaOrResolver) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || get(errorsRef.current, name);\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, [name]);\r\n        }\r\n        else {\r\n            const previousError = get(errorsRef.current, name);\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    (previousError\r\n                        ? !isSameError(previousError, error[name])\r\n                        : true);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, shouldValidateSchemaOrResolver]);\r\n    const setFieldValue = useCallback((field, rawValue) => {\r\n        const { ref, options } = field;\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref)) {\r\n            if (isString(value)) {\r\n                ref.value = value;\r\n            }\r\n            else {\r\n                ref.files = value;\r\n            }\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, [isWeb]);\r\n    const setDirty = useCallback((name) => {\r\n        if (!fieldsRef.current[name] ||\r\n            (!readFormStateRef.current.dirty && !readFormStateRef.current.dirtyFields)) {\r\n            return false;\r\n        }\r\n        let isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousDirtyFieldsLength = dirtyFieldsRef.current.size;\r\n        if (isFieldArray) {\r\n            const fieldArrayName = getFieldArrayParentName(name);\r\n            isFieldDirty = getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, fieldArrayName), get(defaultValuesRef.current, fieldArrayName));\r\n        }\r\n        const isDirtyChanged = (isFieldArray ? isDirtyRef.current : dirtyFieldsRef.current.has(name)) !==\r\n            isFieldDirty;\r\n        if (isFieldDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = isFieldArray\r\n            ? isFieldDirty\r\n            : !!dirtyFieldsRef.current.size;\r\n        return readFormStateRef.current.dirty\r\n            ? isDirtyChanged\r\n            : previousDirtyFieldsLength !== dirtyFieldsRef.current.size;\r\n    }, []);\r\n    const setInternalValues = useCallback((name, value, parentFieldName) => {\r\n        const isValueArray = isArray(value);\r\n        for (const key in value) {\r\n            const fieldName = `${parentFieldName || name}${isValueArray ? `[${key}]` : `.${key}`}`;\r\n            const field = fieldsRef.current[fieldName];\r\n            if (isObject(value[key])) {\r\n                setInternalValues(name, value[key], fieldName);\r\n            }\r\n            if (field) {\r\n                setFieldValue(field, value[key]);\r\n                setDirty(fieldName);\r\n            }\r\n        }\r\n    }, [setFieldValue, setDirty]);\r\n    const setInternalValue = useCallback((name, value) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            setFieldValue(field, value);\r\n            const output = setDirty(name);\r\n            if (isBoolean(output)) {\r\n                return output;\r\n            }\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value);\r\n        }\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, validateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (payload) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fieldsRef.current), validationResolver, validationContextRef.current);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            payload.forEach((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, [name]);\r\n                }\r\n            });\r\n            reRender();\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [\r\n        reRender,\r\n        shouldRenderBaseOnError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const triggerValidation = useCallback(async (payload) => {\r\n        const fields = payload || Object.keys(fieldsRef.current);\r\n        if (shouldValidateSchemaOrResolver) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [\r\n        executeSchemaOrResolverValidation,\r\n        executeValidation,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n    ]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    function setValue(names, valueOrShouldValidate, shouldValidate) {\r\n        let shouldRender = false;\r\n        const isArrayValue = isArray(names);\r\n        (isArrayValue\r\n            ? names\r\n            : [names]).forEach((name) => {\r\n            const isStringFieldName = isString(name);\r\n            shouldRender =\r\n                setInternalValue(isStringFieldName ? name : Object.keys(name)[0], isStringFieldName\r\n                    ? valueOrShouldValidate\r\n                    : Object.values(name)[0]) || isArrayValue\r\n                    ? true\r\n                    : isFieldWatched(name);\r\n        });\r\n        if (shouldRender || isArrayValue) {\r\n            reRender();\r\n        }\r\n        if (shouldValidate || (isArrayValue && valueOrShouldValidate)) {\r\n            triggerValidation(isArrayValue ? undefined : names);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = get(errors, name);\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = skipValidation({\r\n                hasError: !!currentError,\r\n                isOnChange,\r\n                isBlurEvent,\r\n                isOnSubmit,\r\n                isReValidateOnSubmit,\r\n                isOnBlur,\r\n                isReValidateOnBlur,\r\n                isSubmitted: isSubmittedRef.current,\r\n            });\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldRender = isFieldWatched(name) || shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !get(touchedFieldsRef.current, name) &&\r\n                readFormStateRef.current.touched) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                shouldRender = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldRender && reRender();\r\n            }\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors } = await validateWithSchema(validationSchema, validateAllFieldCriteria, getFieldValueByName(fields), validationResolver, validationContextRef.current);\r\n                const previousFormIsValid = isValidRef.current;\r\n                isValidRef.current = isEmptyObject(errors);\r\n                error = (get(errors, name)\r\n                    ? { [name]: get(errors, name) }\r\n                    : {});\r\n                if (previousFormIsValid !== isValidRef.current) {\r\n                    shouldRender = true;\r\n                }\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n            }\r\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaOrResolver = useCallback((values = {}) => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), validationResolver, validationContextRef.current).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, \r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [reRender, validateAllFieldCriteria, validationResolver]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => {\r\n        if (handleChangeRef.current && field) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, forceDelete);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field ||\r\n            (field &&\r\n                isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) &&\r\n                !forceDelete)) {\r\n            return;\r\n        }\r\n        removeFieldEventListener(field, forceDelete);\r\n        const { name } = field.ref;\r\n        errorsRef.current = unset(errorsRef.current, [name]);\r\n        touchedFieldsRef.current = unset(touchedFieldsRef.current, [name]);\r\n        defaultValuesAtRenderRef.current = unset(defaultValuesAtRenderRef.current, [name]);\r\n        [\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach((data) => data.current.delete(name));\r\n        if (readFormStateRef.current.isValid ||\r\n            readFormStateRef.current.touched) {\r\n            reRender();\r\n            if (shouldValidateSchemaOrResolver) {\r\n                validateSchemaOrResolver();\r\n            }\r\n        }\r\n    }, [\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        validateSchemaOrResolver,\r\n        removeFieldEventListener,\r\n    ]);\r\n    function clearError(name) {\r\n        if (name) {\r\n            unset(errorsRef.current, isArray(name) ? name : [name]);\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, shouldRender, }) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(get(errorsRef.current, name), {\r\n            type,\r\n            message,\r\n            types,\r\n        })) {\r\n            set(errorsRef.current, name, {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            });\r\n            if (shouldRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })), { shouldRender: true }));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach((error) => setInternalError(Object.assign({}, error)));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const watchFields = watchFieldsRef.current;\r\n        const isDefaultValueUndefined = isUndefined(defaultValue);\r\n        const combinedDefaultValues = isDefaultValueUndefined\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isDefaultValueUndefined\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        const result = (!isEmptyObject(fieldValues) && fieldValues) || combinedDefaultValues;\r\n        return fieldNames && fieldNames.nest\r\n            ? transformToNestObject(result)\r\n            : result;\r\n    }\r\n    function unregister(name) {\r\n        if (fieldsRef.current) {\r\n            (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            // eslint-disable-next-line no-console\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (isRadioOrCheckbox\r\n            ? field &&\r\n                isArray(field.options) &&\r\n                field.options.filter(Boolean).find((option) => {\r\n                    return value === option.ref.value && option.ref === ref;\r\n                })\r\n            : field && ref === field.ref) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            defaultValue = get(defaultValuesRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (shouldValidateSchemaOrResolver &&\r\n            !isFieldArray &&\r\n            readFormStateRef.current.isValid) {\r\n            validateSchemaOrResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, validateAllFieldCriteria, field).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, field.ref) : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners({\r\n                field: isRadioOrCheckbox && field.options\r\n                    ? field.options[field.options.length - 1]\r\n                    : field,\r\n                isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\r\n                handleChange: handleChangeRef.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, validationOptions) {\r\n        if (isWindowUndefined) {\r\n            return;\r\n        }\r\n        if (isString(refOrValidationOptions)) {\r\n            registerFieldsRef({ name: refOrValidationOptions }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\r\n            registerFieldsRef(refOrValidationOptions, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidationOptions);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        const fields = fieldsRef.current;\r\n        let fieldValues = getFieldsValues(fields);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (shouldValidateSchemaOrResolver) {\r\n                const { errors, values } = await validateWithSchema(validationSchema, validateAllFieldCriteria, transformToNestObject(fieldValues), validationResolver, validationContextRef.current);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fields)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, validateAllFieldCriteria, field);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else {\r\n                            if (fieldsWithValidationRef.current.has(name)) {\r\n                                validFieldsRef.current.add(name);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(transformToNestObject(fieldValues), e);\r\n            }\r\n            else {\r\n                errorsRef.current = fieldErrors;\r\n                if (submitFocusError && isWeb) {\r\n                    focusOnErrorField(fields, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        isWeb,\r\n        reRender,\r\n        shouldValidateSchemaOrResolver,\r\n        submitFocusError,\r\n        validateAllFieldCriteria,\r\n        validationResolver,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = ({ errors, dirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        fieldsRef.current = {};\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!dirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = new Set();\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return fieldsRef.current[payload]\r\n                ? getFieldValue(fieldsRef.current, fieldsRef.current[payload].ref)\r\n                : get(defaultValuesRef.current, payload);\r\n        }\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValuesRef.current\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? transformToNestObject(outputValues)\r\n            : outputValues;\r\n    }\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            process.env.NODE_ENV === 'production' &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!shouldValidateSchemaOrResolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        triggerValidation,\r\n        setValue: useCallback(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            triggerValidation,\r\n        ]),\r\n        register: useCallback(register, [\r\n            defaultValuesRef.current,\r\n            defaultValuesAtRenderRef.current,\r\n        ]),\r\n        unregister: useCallback(unregister, []),\r\n        getValues: useCallback(getValues, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign(Object.assign({ removeFieldEventListener,\r\n        reRender }, (shouldValidateSchemaOrResolver\r\n        ? { validateSchemaIsValid: validateSchemaOrResolver }\r\n        : {})), { mode: {\r\n            isOnBlur,\r\n            isOnSubmit,\r\n            isOnChange,\r\n        }, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnSubmit,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        readFormStateRef,\r\n        defaultValuesRef }), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: useCallback(reset, []), clearError: useCallback(clearError, []), setError: useCallback(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(_a) {\r\n    var { children, formState, errors } = _a, restMethods = __rest(_a, [\"children\", \"formState\", \"errors\"]);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nvar getSortRemovedItems = (indexes, removeIndexes, updatedIndexes = [], count = 0, notFoundIndexes = []) => {\r\n    for (const removeIndex of removeIndexes) {\r\n        if (indexes.indexOf(removeIndex) < 0) {\r\n            notFoundIndexes.push(removeIndex);\r\n        }\r\n    }\r\n    for (const index of indexes.sort()) {\r\n        if (removeIndexes.indexOf(index) > -1) {\r\n            updatedIndexes.push(-1);\r\n            count++;\r\n        }\r\n        else {\r\n            updatedIndexes.push(index -\r\n                count -\r\n                (notFoundIndexes.length\r\n                    ? notFoundIndexes\r\n                        .map((notFoundIndex) => notFoundIndex < index)\r\n                        .filter(Boolean).length\r\n                    : 0));\r\n        }\r\n    }\r\n    return updatedIndexes;\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return data.filter(Boolean);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || null]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || null]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(null) : null;\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, getValues, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, } = control || methods.control;\r\n    const getDefaultValues = () => [\r\n        ...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)]\r\n            ? fieldArrayDefaultValues.current\r\n            : defaultValuesRef.current, name, []),\r\n    ];\r\n    const memoizedDefaultValues = useRef(getDefaultValues());\r\n    const [fields, setField] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    const [isDeleted, setIsDeleted] = useState(false);\r\n    const allFields = useRef(fields);\r\n    const isNameKey = isKey(name);\r\n    allFields.current = fields;\r\n    if (isNameKey) {\r\n        fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const modifyDirtyFields = ({ shouldRender, isRemove, isPrePend, index, value = {}, } = {}) => {\r\n        let render = shouldRender;\r\n        const values = isArray(value) ? value : [value];\r\n        if (readFormStateRef.current.dirty) {\r\n            const dirtyFieldIndexesAndValues = {};\r\n            if (isPrePend || isRemove) {\r\n                for (const dirtyField of [...dirtyFieldsRef.current].sort()) {\r\n                    if (isMatchFieldArrayName(dirtyField, name)) {\r\n                        const matchedIndexes = dirtyField.match(REGEX_ARRAY_FIELD_INDEX);\r\n                        if (matchedIndexes) {\r\n                            const matchIndex = +matchedIndexes[matchedIndexes.length - 1];\r\n                            if (dirtyFieldIndexesAndValues[matchIndex]) {\r\n                                dirtyFieldIndexesAndValues[matchIndex].push(dirtyField);\r\n                            }\r\n                            else {\r\n                                dirtyFieldIndexesAndValues[matchIndex] = [dirtyField];\r\n                            }\r\n                        }\r\n                        dirtyFieldsRef.current.delete(dirtyField);\r\n                    }\r\n                }\r\n            }\r\n            if (!isUndefined(index) || isPrePend) {\r\n                const updatedDirtyFieldIndexes = isUndefined(index)\r\n                    ? []\r\n                    : getSortRemovedItems(Object.keys(dirtyFieldIndexesAndValues).map((i) => +i), isArray(index) ? index : [index]);\r\n                Object.values(dirtyFieldIndexesAndValues).forEach((values, index) => {\r\n                    const updateIndex = isPrePend ? 0 : updatedDirtyFieldIndexes[index];\r\n                    if (updateIndex > -1) {\r\n                        for (const value of values) {\r\n                            const matchedIndexes = value.match(REGEX_ARRAY_FIELD_INDEX);\r\n                            if (matchedIndexes) {\r\n                                dirtyFieldsRef.current.add(value.replace(/[\\d+]([^[\\d+]+)$/, `${isPrePend\r\n                                    ? +matchedIndexes[matchedIndexes.length - 1] +\r\n                                        values.length\r\n                                    : updateIndex}$1`));\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (!isRemove) {\r\n                values.forEach((fieldValue, index) => Object.keys(fieldValue).forEach((key) => dirtyFieldsRef.current.add(`${name}[${isPrePend ? index : allFields.current.length + index}].${key}`)));\r\n                isDirtyRef.current = true;\r\n            }\r\n            render = true;\r\n        }\r\n        if (render && !isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.dirty) {\r\n            isDirtyRef.current = isUndefined(flagOrFields)\r\n                ? true\r\n                : getIsFieldsDifferent(flagOrFields, defaultValuesRef.current[name] || []);\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const mapCurrentFieldsValueWithState = () => {\r\n        const currentFieldsValue = get(getValues({ nest: true }), name);\r\n        if (isArray(currentFieldsValue)) {\r\n            for (let i = 0; i < currentFieldsValue.length; i++) {\r\n                allFields.current[i] = Object.assign(Object.assign({}, allFields.current[i]), currentFieldsValue[i]);\r\n            }\r\n        }\r\n    };\r\n    const append = (value) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        modifyDirtyFields({ value });\r\n    };\r\n    const prepend$1 = (value) => {\r\n        let shouldRender = false;\r\n        resetFields();\r\n        setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = prepend(errorsRef.current[name], fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], fillEmptyArray(value));\r\n            shouldRender = true;\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isPrePend: true,\r\n            value,\r\n        });\r\n    };\r\n    const remove = (index) => {\r\n        let shouldRender = false;\r\n        const isIndexUndefined = isUndefined(index);\r\n        if (!isIndexUndefined) {\r\n            mapCurrentFieldsValueWithState();\r\n        }\r\n        resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(removeArrayAt(allFields.current, index));\r\n        setIsDeleted(true);\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = removeArrayAt(errorsRef.current[name], index);\r\n            if (!errorsRef.current[name].filter(Boolean).length) {\r\n                delete errorsRef.current[name];\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        modifyDirtyFields({\r\n            shouldRender,\r\n            isRemove: true,\r\n            index,\r\n        });\r\n    };\r\n    const insert$1 = (index, value) => {\r\n        mapCurrentFieldsValueWithState();\r\n        resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\r\n        setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        if (errorsRef.current[name]) {\r\n            errorsRef.current[name] = insert(errorsRef.current[name], index, fillEmptyArray(value));\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, fillEmptyArray(value));\r\n            reRender();\r\n        }\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        swapArrayAt(allFields.current, indexA, indexB);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            swapArrayAt(errorsRef.current[name], indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\r\n            reRender();\r\n        }\r\n    };\r\n    const move = (from, to) => {\r\n        mapCurrentFieldsValueWithState();\r\n        const fieldValues = getFieldValueByName(fieldsRef.current, name);\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        moveArrayAt(allFields.current, from, to);\r\n        setFieldAndValidState([...allFields.current]);\r\n        if (errorsRef.current[name]) {\r\n            moveArrayAt(errorsRef.current[name], from, to);\r\n        }\r\n        if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\r\n            moveArrayAt(touchedFieldsRef.current[name], from, to);\r\n            reRender();\r\n        }\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    useEffect(() => {\r\n        if (isNameKey &&\r\n            isDeleted &&\r\n            fieldArrayDefaultValues.current[name] &&\r\n            fields.length < fieldArrayDefaultValues.current[name].length) {\r\n            fieldArrayDefaultValues.current[name].pop();\r\n        }\r\n    }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey]);\r\n    useEffect(() => {\r\n        if (isWatchAllRef && isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }, [fields, name, reRender, watchFieldsRef, isWatchAllRef]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        fieldArrayNames.add(name);\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [fields, name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isCheckboxInput || isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as: InnerComponent, onBlur, onChange, onChangeName = VALIDATION_MODE.onChange, onBlurName = VALIDATION_MODE.onBlur, valueName, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"onBlur\", \"onChange\", \"onChangeName\", \"onBlurName\", \"valueName\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, setValue, register, unregister, errorsRef, removeFieldEventListener, triggerValidation, mode: { isOnSubmit, isOnBlur, isOnChange }, reValidateMode: { isReValidateOnBlur, isReValidateOnSubmit }, formState: { isSubmitted }, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, } = control || methods.control;\r\n    const [value, setInputStateValue] = useState(isUndefined(defaultValue)\r\n        ? get(defaultValuesRef.current, name)\r\n        : defaultValue);\r\n    const valueRef = useRef(value);\r\n    const isCheckboxInput = isBoolean(value);\r\n    const shouldReValidateOnBlur = isOnBlur || isReValidateOnBlur;\r\n    const rulesRef = useRef(rules);\r\n    const onFocusRef = useRef(onFocus);\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    rulesRef.current = rules;\r\n    const shouldValidate = () => !skipValidation({\r\n        hasError: !!get(errorsRef.current, name),\r\n        isOnBlur,\r\n        isOnSubmit,\r\n        isOnChange,\r\n        isReValidateOnBlur,\r\n        isReValidateOnSubmit,\r\n        isSubmitted,\r\n    });\r\n    const commonTask = (event) => {\r\n        const data = getInputValue(event, isCheckboxInput);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const eventWrapper = (event) => (...arg) => setValue(name, commonTask(event(arg)), shouldValidate());\r\n    const handleChange = (event) => {\r\n        const data = commonTask(event);\r\n        setValue(name, data, shouldValidate());\r\n    };\r\n    const registerField = useCallback(() => {\r\n        if (!isNotFieldArray) {\r\n            removeFieldEventListener(fieldsRef.current[name], true);\r\n        }\r\n        register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n            set(data) {\r\n                setInputStateValue(data);\r\n                valueRef.current = data;\r\n            },\r\n            get() {\r\n                return valueRef.current;\r\n            },\r\n        }), rulesRef.current);\r\n    }, [\r\n        isNotFieldArray,\r\n        fieldsRef,\r\n        rulesRef,\r\n        name,\r\n        onFocusRef,\r\n        register,\r\n        removeFieldEventListener,\r\n    ]);\r\n    useEffect(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    useEffect(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    useEffect(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(isUndefined(defaultValue)\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : defaultValue);\r\n            }\r\n        }\r\n    });\r\n    const props = Object.assign(Object.assign(Object.assign(Object.assign({ name }, rest), (onChange\r\n        ? { [onChangeName]: eventWrapper(onChange) }\r\n        : { [onChangeName]: handleChange })), { [onBlurName]: (...args) => {\r\n            if (onBlur) {\r\n                onBlur(args);\r\n            }\r\n            if (readFormStateRef.current.touched &&\r\n                !get(touchedFieldsRef.current, name)) {\r\n                set(touchedFieldsRef.current, name, true);\r\n                reRender();\r\n            }\r\n            if (shouldReValidateOnBlur) {\r\n                triggerValidation(name);\r\n            }\r\n        } }), { [valueName || (isCheckboxInput ? 'checked' : VALUE)]: value });\r\n    return isValidElement(InnerComponent)\r\n        ? cloneElement(InnerComponent, props)\r\n        : createElement(InnerComponent, props);\r\n};\n\nconst ErrorMessage = (_a) => {\r\n    var { as: InnerComponent, errors, name, message, children } = _a, rest = __rest(_a, [\"as\", \"errors\", \"name\", \"message\", \"children\"]);\r\n    const methods = useFormContext();\r\n    const error = get(errors || methods.errors, name);\r\n    if (!error) {\r\n        return null;\r\n    }\r\n    const { message: messageFromRegister, types } = error;\r\n    const props = Object.assign(Object.assign({}, (InnerComponent ? rest : {})), { children: children\r\n            ? children({ message: messageFromRegister || message, messages: types })\r\n            : messageFromRegister || message });\r\n    return InnerComponent ? (isValidElement(InnerComponent) ? (cloneElement(InnerComponent, props)) : (createElement(InnerComponent, props))) : (createElement(Fragment, Object.assign({}, props)));\r\n};\n\nexport { Controller, ErrorMessage, FormContext, useFieldArray, useForm, useFormContext };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}